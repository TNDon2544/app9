/**
 * HTTPS is the HTTP protocol over TLS/SSL. In Node.js this is implemented as a
 * separate module.
 * @see [source](https://github.com/nodejs/node/blob/v18.0.0/lib/https.js)
 */
declare module 'https' {
    import { Duplex } from 'node:stream';
    import * as tls from 'node:tls';
    import * as http from 'node:http';
    import { URL } from 'node:url';
    type ServerOptions<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    > = tls.SecureContextOptions & tls.TlsOptions & http.ServerOptions<Request, Response>;
    type RequestOptions = http.RequestOptions &
        tls.SecureContextOptions & {
            rejectUnauthorized?: boolean | undefined; // Defaults to true
            servername?: string | undefined; // SNI TLS Extension
        };
    interface AgentOptions extends http.AgentOptions, tls.ConnectionOptions {
        rejectUnauthorized?: boolean | undefined;
        maxCachedSessions?: number | undefined;
    }
    /**
     * An `Agent` object for HTTPS similar to `http.Agent`. See {@link request} for more information.
     * @since v0.4.5
     */
    class Agent extends http.Agent {
        constructor(options?: AgentOptions);
        options: AgentOptions;
    }
    interface Server<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    > extends http.Server<Request, Response> {}
    /**
     * See `http.Server` for more information.
     * @since v0.3.4
     */
    class Server<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    > extends tls.Server {
        constructor(requestListener?: http.RequestListener<Request, Response>);
        constructor(
            options: ServerOptions<Request, Response>,
            requestListener?: http.RequestListener<Request, Response>,
        );
        /**
         * Closes all connections connected to this server.
         * @since v18.2.0
         */
        closeAllConnections(): void;
        /**
         * Closes all connections connected to this server which are not sending a request or waiting for a response.
         * @since v18.2.0
         */
        closeIdleConnections(): void;
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: 'keylog', listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        addListener(
            event: 'newSession',
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        addListener(
            event: 'OCSPRequest',
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        addListener(
            event: 'resumeSession',
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        addListener(event: 'secureConnection', listener: (tlsSocket: tls.TLSSocket) => void): this;
        addListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        addListener(event: 'close', listener: () => void): this;
        addListener(event: 'connection', listener: (socket: Duplex) => void): this;
        addListener(event: 'error', listener: (err: Error) => void): this;
        addListener(event: 'listening', listener: () => void): this;
        addListener(event: 'checkContinue', listener: http.RequestListener<Request, Response>): this;
        addListener(event: 'checkExpectation', listener: http.RequestListener<Request, Response>): this;
        addListener(event: 'clientError', listener: (err: Error, socket: Duplex) => void): this;
        addListener(
            event: 'connect',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        addListener(event: 'request', listener: http.RequestListener<Request, Response>): this;
        addListener(
            event: 'upgrade',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        emit(event: string, ...args: any[]): boolean;
        emit(event: 'keylog', line: Buffer, tlsSocket: tls.TLSSocket): boolean;
        emit(
            event: 'newSession',
            sessionId: Buffer,
            sessionData: Buffer,
            callback: (err: Error, resp: Buffer) => void,
        ): boolean;
        emit(
            event: 'OCSPRequest',
            certificate: Buffer,
            issuer: Buffer,
            callback: (err: Error | null, resp: Buffer) => void,
        ): boolean;
        emit(event: 'resumeSession', sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void): boolean;
        emit(event: 'secureConnection', tlsSocket: tls.TLSSocket): boolean;
        emit(event: 'tlsClientError', err: Error, tlsSocket: tls.TLSSocket): boolean;
        emit(event: 'close'): boolean;
        emit(event: 'connection', socket: Duplex): boolean;
        emit(event: 'error', err: Error): boolean;
        emit(event: 'listening'): boolean;
        emit(
            event: 'checkContinue',
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(
            event: 'checkExpectation',
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: 'clientError', err: Error, socket: Duplex): boolean;
        emit(event: 'connect', req: InstanceType<Request>, socket: Duplex, head: Buffer): boolean;
        emit(
            event: 'request',
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: 'upgrade', req: InstanceType<Request>, socket: Duplex, head: Buffer): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: 'keylog', listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        on(
            event: 'newSession',
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        on(
            event: 'OCSPRequest',
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        on(
            event: 'resumeSession',
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        on(event: 'secureConnection', listener: (tlsSocket: tls.TLSSocket) => void): this;
        on(event: 'tlsClientError', listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        on(event: 'close', listener: () => void): this;
        on(event: 'connection', listener: (socket: Duplex) => void): this;
        on(event: 'error', listener: (err: Error) => void): this;
        on(event: 'listening', listener: () => void): this;
        on(event: 'checkContinue', listener: http.RequestListener<Request, Response>): this;
        on(event: 'checkExpectation', listener: http.RequestListener<Request, Response>): this;
        on(event: 'clientError', listener: (err: Error, socket: Duplex) => void): this;
        on(event: 'connect', listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        on(event: 'request', listener: http.RequestListener<Request, Response>): this;
        on(event: 'upgrade', listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: 'keylog', listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        once(
            event: 'newSession',
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        once(
            event: 'OCSPRequest',
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        once(
            event: 'resumeSession',
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        once(event: 'secureConnection', listener: (tlsSocket: tls.TLSSocket) => void): this;
        once(event: 'tlsClientError', listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        once(event: 'close', listener: () => void): this;
        once(event: 'connection', listener: (socket: Duplex) => void): this;
        once(event: 'error', listener: (err: Error) => void): this;
        once(event: 'listening', listener: () => void): this;
        once(event: 'checkContinue', listener: http.RequestListener<Request, Response>): this;
        once(event: 'checkExpectation', listener: http.RequestListener<Request, Response>): this;
        once(event: 'clientError', listener: (err: Error, socket: Duplex) => void): this;
        once(event: 'connect', listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        once(event: 'request', listener: http.RequestListener<Request, Response>): this;
        once(event: 'upgrade', listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: 'keylog', listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        prependListener(
            event: 'newSession',
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        prependListener(
            event: 'OCSPRequest',
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        prependListener(
            event: 'resumeSession',
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        prependListener(event: 'secureConnection', listener: (tlsSocket: tls.TLSSocket) => void): this;
        prependListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        prependListener(event: 'close', listener: () => void): this;
        prependListener(event: 'connection', listener: (socket: Duplex) => void): this;
        prependListener(event: 'error', listener: (err: Error) => void): this;
        prependListener(event: 'listening', listener: () => void): this;
        prependListener(event: 'checkContinue', listener: http.RequestListener<Request, Response>): this;
        prependListener(event: 'checkExpectation', listener: http.RequestListener<Request, Response>): this;
        prependListener(event: 'clientError', listener: (err: Error, socket: Duplex) => void): this;
        prependListener(
            event: 'connect',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependListener(event: 'request', listener: http.RequestListener<Request, Response>): this;
        prependListener(
            event: 'upgrade',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'keylog', listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(
            event: 'newSession',
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        prependOnceListener(
            event: 'OCSPRequest',
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        prependOnceListener(
            event: 'resumeSession',
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        prependOnceListener(event: 'secureConnection', listener: (tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(event: 'close', listener: () => void): this;
        prependOnceListener(event: 'connection', listener: (socket: Duplex) => void): this;
        prependOnceListener(event: 'error', listener: (err: Error) => void): this;
        prependOnceListener(event: 'listening', listener: () => void): this;
        prependOnceListener(event: 'checkContinue', listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(event: 'checkExpectation', listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(event: 'clientError', listener: (err: Error, socket: Duplex) => void): this;
        prependOnceListener(
            event: 'connect',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(event: 'request', listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(
            event: 'upgrade',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
    }
    /**
     * ```js
     * // curl -k https://localhost:8000/
     * const https = require('https');
     * const fs = require('fs');
     *
     * const options = {
     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')
     * };
     *
     * https.createServer(options, (req, res) => {
     *   res.writeHead(200);
     *   res.end('hello world\n');
     * }).listen(8000);
     * ```
     *
     * Or
     *
     * ```js
     * const https = require('https');
     * const fs = require('fs');
     *
     * const options = {
     *   pfx: fs.readFileSync('test/fixtures/test_cert.pfx'),
     *   passphrase: 'sample'
     * };
     *
     * https.createServer(options, (req, res) => {
     *   res.writeHead(200);
     *   res.end('hello world\n');
     * }).listen(8000);
     * ```
     * @since v0.3.4
     * @param options Accepts `options` from `createServer`, `createSecureContext` and `createServer`.
     * @param requestListener A listener to be added to the `'request'` event.
     */
    function createServer<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    >(requestListener?: http.RequestListener<Request, Response>): Server<Request, Response>;
    function createServer<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    >(
        options: ServerOptions<Request, Response>,
        requestListener?: http.RequestListener<Request, Response>,
    ): Server<Request, Response>;
    /**
     * Makes a request to a secure web server.
     *
     * The following additional `options` from `tls.connect()` are also accepted:`ca`, `cert`, `ciphers`, `clientCertEngine`, `crl`, `dhparam`, `ecdhCurve`,`honorCipherOrder`, `key`, `passphrase`,
     * `pfx`, `rejectUnauthorized`,`secureOptions`, `secureProtocol`, `servername`, `sessionIdContext`,`highWaterMark`.
     *
     * `options` can be an object, a string, or a `URL` object. If `options` is a
     * string, it is automatically parsed with `new URL()`. If it is a `URL` object, it will be automatically converted to an ordinary `options` object.
     *
     * `https.request()` returns an instance of the `http.ClientRequest` class. The `ClientRequest` instance is a writable stream. If one needs to
     * upload a file with a POST request, then write to the `ClientRequest` object.
     *
     * ```js
     * const https = require('https');
     *
     * const options = {
     *   hostname: 'encrypted.google.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET'
     * };
     *
     * const req = https.request(options, (res) => {
     *   console.log('statusCode:', res.statusCode);
     *   console.log('headers:', res.headers);
     *
     *   res.on('data', (d) => {
     *     process.stdout.write(d);
     *   });
     * });
     *
     * req.on('error', (e) => {
     *   console.error(e);
     * });
     * req.end();
     * ```
     *
     * Example using options from `tls.connect()`:
     *
     * ```js
     * const options = {
     *   hostname: 'encrypted.google.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET',
     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')
     * };
     * options.agent = new https.Agent(options);
     *
     * const req = https.request(options, (res) => {
     *   // ...
     * });
     * ```
     *
     * Alternatively, opt out of connection pooling by not using an `Agent`.
     *
     * ```js
     * const options = {
     *   hostname: 'encrypted.google.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET',
     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),
     *   agent: false
     * };
     *
     * const req = https.request(options, (res) => {
     *   // ...
     * });
     * ```
     *
     * Example using a `URL` as `options`:
     *
     * ```js
     * const options = new URL('https://abc:xyz@example.com');
     *
     * const req = https.request(options, (res) => {
     *   // ...
     * });
     * ```
     *
     * Example pinning on certificate fingerprint, or the public key (similar to`pin-sha256`):
     *
     * ```js
     * const tls = require('tls');
     * const https = require('https');
     * const crypto = require('crypto');
     *
     * function sha256(s) {
     *   return crypto.createHash('sha256').update(s).digest('base64');
     * }
     * const options = {
     *   hostname: 'github.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET',
     *   checkServerIdentity: function(host, cert) {
     *     // Make sure the certificate is issued to the host we are connected to
     *     const err = tls.checkServerIdentity(host, cert);
     *     if (err) {
     *       return err;
     *     }
     *
     *     // Pin the public key, similar to HPKP pin-sha25 pinning
     *     const pubkey256 = 'pL1+qb9HTMRZJmuC/bB/ZI9d302BYrrqiVuRyW+DGrU=';
     *     if (sha256(cert.pubkey) !== pubkey256) {
     *       const msg = 'Certificate verification error: ' +
     *         `The public key of '${cert.subject.CN}' ` +
     *         'does not match our pinned fingerprint';
     *       return new Error(msg);
     *     }
     *
     *     // Pin the exact certificate, rather than the pub key
     *     const cert256 = '25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:' +
     *       'D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16';
     *     if (cert.fingerprint256 !== cert256) {
     *       const msg = 'Certificate verification error: ' +
     *         `The certificate of '${cert.subject.CN}' ` +
     *         'does not match our pinned fingerprint';
     *       return new Error(msg);
     *     }
     *
     *     // This loop is informational only.
     *     // Print the certificate and public key fingerprints of all certs in the
     *     // chain. Its common to pin the public key of the issuer on the public
     *     // internet, while pinning the publÚCõPA30€¼Ñ‰†¯Õ°^ĞÇÄâ4 
Û[°v‡ Ó½µ„×U>â          “.ğ<»»»»»»»»»»»+³³²Ô±»»»»»»»»»³²»+{± ğÿ 5 À şï€ÿ  ¤ÿ ü ş ğ† WwwKWOOÍQÉtQSUSO`ØuSOWwW7MQwuIÓĞôôTµtwSœĞonu—A ?ş÷äÖe0IC±†ŒƒĞGuş{CFBêGr†±Áˆ»	ÿIŒÃş‚°
¸19EÍ¬¦s™2j2Î"p¾º?DF&hÉ|B0@ÈA"Á>Ş¼Rş‘G”%ŠQ ÈUa@¬±ÀS³š¡"R   €)«€!+€HR8)+M
KSFháNiÒ&-#)MYiZŠ0MÓ†6MáĞ&-+´ÌHá´iÓ4mhÓ¦ì4Œ¦4iS8Œ6Œ&…C›´)«M¥¡mJSš6¬D]àP€Š5iS,«Š6D	*Û£ÆW®%\%W‚Hõê&Óu©‘İN„\OŒ”˜¸‘ªÛ´ÓKÉÉmšÜ.!&7mˆÍM"7×¦6W©]íz!jÔ• F®7b#·ÛMİøvãÏÔ;±Gk(lzâj\“‹Ûå¦†2 8hÄĞ@Æ^"Ãœc‰`XÂÀâÁúH~rq	"—ã"y$H\öÀò¸P—KÄå‘ˆË.Œ6yß¾}Ã-RoyEJ9}ËIyõROÑ×Ó·Şòz B@€à @ÄO2òXøIÖ¨$œh¶::­„!®;B,ê±È#ÄGˆ‹ P®³ø.³ª}ÅQÜqU­ Pe²ÊäZVsĞæÇr ¿xÿUˆ¨Ñ;KGÛT¶ŸCüw¿Jqgo¯ÂL¥ÑÙ(:ğÏ$00ÄXdéwÉ=ï°êÉmí¯à*½êQV­RÚ9JV9tö¬UÔªD{ç=@õşDì($ñ‹<—gEù§MÒÿí0ıJZı¹í	ëı¤¯qÏ)á! òºYHé¤^Ø¹·[Ó
‘çIs…Š*6çç™¡æ¬f~ÆÈüüE(UAp(µ,;© ¨ÓY8éy¶Œşw£ùÃûNüµKfaPzz!ÕOº¿)ü‰‰'6}!tOşÅFé)­yĞbü‡1Gåÿrü£èqÌ,‹ÿxŸĞ}Bóx¼şÁ„?gÀOOŒğgÛë½¶ı½°oDbŒÙÃ¥„7İ?Äÿ,ÂŸ:ş=ŸŸáÇ£?G‡ØÇæ/ã]éŸ{¾	üwËzğÒ_Fù%8>6Eï{Ò^Ú¶Àã[é{ÌşêZ5ÿâüN9=Cùæ+Ïÿ«oÿmÿ;š…ÿÌ~’¡2r1ÛÂ‘@Ü,‘åaˆ$¤W)Şz„3dJè * ÖYüO,…i™™5:~vq¨ˆ	C.õ% ş2»É^â£{ä#W] äb¾rqWqç¾§Œ“¯æ œø´ø¦z¸ÈpgÚïfbŞh—¤ñïÎ½?û}W‘/<”ª~»
J¼¢û"×·u”Çô~dé+Ã– 0KıM³s7?oóó6?oóó2?/(Ñ 	Ø£$`oºUc¤ğl((<R\Ï#„+Ğ g­Ğ`µ—\0¤«n¢%%$À-t”Wkòy¦œ `äÌ1/íÏmÌ²rû‡CÀšÅû˜fA¾Ôş! Î>Pÿ7Ä,Ğwÿ@í?á %.ÔúK ˆşû|20úÁ©:Ÿ{Íò}GÆÌÂ}úÂq¯ÌÂ˜€ÉtñÌbL’~•Î²~qÑy38/¼¿éÎZ.ãóÖıõ×L~ıeö¤ôŞbøVÇO6ï únüqÅ»ü~+z™ÿ/™ïù.õ]FËê5	¯³{çïÙ¿¼ƒ|VıÛp¿‘ø;‹şE\Şqù€Ï[æØüÂó;ùãÀßààö³ü#ø¿Y}öØyïà«î'ë_\Şáõ1¹ÿëGD–fYºç™…éÎ¦ËşîÁı!>‰ÿ«¡¿ş˜
·Ìùùy>XşçsX
|rDßåşè~£tIĞK¹Ëz:šOoöÚá?% ÷'Åc¸ı	Eş/æ¿¢¾–ØßèéÿÑÿm¢ŞûwlâŸ¶ñı»„şó’~ûşÓ1¾Ãä ÷°œaÒïÖ§•øì&&2úÇíÿ\#òoCJïñşcèè¿B1×?½sùìxÂûqÌƒQı,Îÿ:¨_Î’¢Ü"ğ™‰?ä/Oz…îÓÁ`;^OíùD,¸.-pû“î’¿YQü)[ÔŸ~É}ĞËèßuß*ÿaöÇÃ(ÿ^ò|ãdÕkÆ_YõŸ\»X«¼ñkß©U^«¼ñTûMÔ“‰~©îW/Hö™Ş2[0zÌ5O7şïhô–Ù¢ÑƒÄãùKşÂ*ù]òĞJ”—?•‚ÏUŸtÿyü»i ßSîÅğNñ<€‹-üÿ–|ãm$`. D|®€è @D’Uíª-ç)šŸ€"FG$+ yl0{ÿe(R¿ÚPœEJÎ4`ÚÍÚ€yAx­ÂzàÊ;õª¨áZjç”zNXÏ2³³\ÒÙê;ÎÍö'_ùÿûìŸÍ-ÚùaÅRù£­{yîRÎ?šDIúÔ´ĞğfåW¾?9Íú~ ,F-~%ÿsü]óHä/¼ ésqz¡êW²|z¬KÊ4ºùñÖX}³Z´]´]ÂúòÁ7°¾ëK¬Íø#FFë·ñ7Ç_ß÷J¾ÿy¯·ılóóËIø©9ıAX`ş_lòmÿ—¹¼¿ŒĞı¹ÌàÿúÄ?JôßÅov~ix¢º‡Û£tÿ‡ õ1ú¤×§Ã'µçÙ,_ïÏt©óÛœ·?báól„½šíñçuSĞôÙw¥}År–óå¨d#gyßqöSGÏ«€Öy3e!F2}öóãÏCñäòÔ¤ÊÉenbÏ¾Ä‘GŠeê‡)H¹÷j!O`ò#'æ6›8¡ø¢£ø¶[}–2~ê¿tüÄ¨íkÅĞ3’€.êt¿ªİÉFÎW@é"íØ´“æ¯švüãàŒşïi¥ñü¢ÇN"ÇŞâ1ö¦˜¯Ø¦™C§¨x#üú&v hÖ“³@æ)[æËâ¡šÆòƒÌó4!çÙs¨>º‚È—õù²¬âGL.òAÁ	ş’~äƒ0âúJ:“[PøWJC§À¡ï®@Ÿq”ˆzû éCçğ_–á¯kYYª)áS9ñ—õ•İÈb´¬ Í¢¸ˆõ5å¸d}Àï]#o°øSÖw*c‹ú `ÊØ‚Âá/ÄÕH^ûf7ö3Ÿï×Òáy8ĞÁÆN!có2Â—HF?Ñ>±>QÒ‹eáOŠ|øõ±E8Ão?yÈ]‰:a‚!¤(]4I&¥—v,}:yéÅ‚°ş¡—¡úÈg>8ì½Ri'Ş×ot„c$í­¬¯Ùƒ_Ù~ë£üÅt±£Šy¬ÒN†ÂßGÓµ4Êé]\¡OnGù‰²§G—Ø|é¡t’>zê]{ÜÀ‰ÿèW"ó”@¡ôE¿Ñ%ÙÒ¿à§t""¨â›)¥w¹H?éDôùĞ‡UTK³àÍØêœ¹,“³Z&o¥ÊÍJ•§Õ25+4¬nTÙ[­8­4R>‹iDgÇYÔq.X<Î…EÛrj›
Æg#¬p!®U+´îöUÑ¹\è~ÎÜÅ/w,“Ş«}PÕìvW‘‚.3¸WS•ÅTWLÎÁ,wç£>×üÖeN­çÂ¸u™[ÁÙKuâºUIèVÙ¤.ÀÑ½$ª{Qàu±¤{©´{‘Ûu1¯{)¿{1ãºÈ²{‰u÷b
Ä'İ‹t!VNëºhäÏƒ{=¹¡rÒWåunOÂ°åqb;>fãöf_óIBó»eÍ'zÜŞ(ñiZìgVĞÓûg4¶¾_D£õ;õ¶k…š®_JÈ}1]†èşĞšë
ò³¤j¾VÌI˜ŸâZO3­§ÖÖo¨€<OG­åàAƒu˜¬­n_lÔ`_şATÈ‚ª˜¬ÖÑ'©¢_4İròP#§åÁÕÊe%kùÅ“Ÿ±¸~K ó¹,wUç	ˆ.òlY*n9ùæØ¶œ²!:rVÃdå°’¹Âl%}…íJê
x ¶}†wœ"@Ü÷)¦qRÜ¼”š«œ-È,ùÁö3({òÓŒ,æåÚ@mr+óNö§ö¥<R§q§}ûI@û)–ì©¸ıäÒ¾äOäD *˜Ú­HÌs;Yª1[0ğyBBÛj„r9!U3^x20åŸôÕP.8Í´h«‘¿6Â=åÍêÎÏ)¯éò¡›ÈSj¨íÄ£ñÄ¶ídÜ¦¨‰h1+ahT q$ï„Zd&+ˆrO­§L1'¥ 8Vµ.â>M@ş"ƒÖ“ıB2I¯ĞY	X‰[ÁùÅdÃ¦­¼Ô0h>‘¿¤	™wéø˜u}©Áâgiı‰wıûn­§<`&‚{!˜ë/\¸WÎJ®î÷ÛòH|¯ õ–1t
áòoìÍŸ,üyLjæÍ¯GTbßvcü&çºûºÂ½7MüM’Ğ´óòè b(—ßSÂê$Œø‡Y/q€ämghğU¿"¡"dT}Ó0O¸ùÄ¿q'ˆ(Ğ}©_Ã©ÇåÅÀ%«†E@µzÕÚR@ã÷ĞÆ%§¼B%x…ÂJôJÌJì
­ö+î_ìê?‡CÅ#nå"O6 8NrşæŸ¦¯b=Gô†ö»?rèª'}0k|Cûm–¢×ä»ıÖMÕÌ×Ú;™Ñ&]÷ŒÕã:ÎL33×¡üº¶¿óoİ4º:ƒ§¹XB	¨À¬Mç¡eÒyª'/ó^ãså»•ùAÎ†ñ»¿Æ¨'J5—H(¹¶¥ñºµzÍŞĞ~‡4hô5½I³šµ¬ån…’í,V£7äßã@F”>˜/a3oˆ–¨ñ	€m÷ß{Á·Øâ¸n5lb,ù6’[U{oˆ†Í‹¶¾Ó•ÀÆÅaÅb°^ÑûV(ÚÌ_ò Dà}å9WXGxûmÄMƒ « áê±Ö Vı+ş”Ãz?EßÉ`­_F·DØÎ×;ùÎ¿û	CÓ >è0ş^ö=å)Ù¿
H, ïOê½´õáQÑÅôšYı YüïÉ¤µŠ€gé?Hş`q ãÎeÀğ\¢ÏJÛóöTy¸÷áöº½Î]!‚3‡[ ŞEşÑ-ñÚ¥wI¼¥€sÙ°ê º9Şòõ/õÎÙş¨zÒşZuäîptÌ†£ÿ-Xí â#Ú™£Û•öí¤ä2Ã ¡Z†ª