/**
 * The `url` module provides utilities for URL resolution and parsing. It can be
 * accessed using:
 *
 * ```js
 * import url from 'url';
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v18.0.0/lib/url.js)
 */
declare module 'url' {
    import { Blob as NodeBlob } from 'node:buffer';
    import { ClientRequestArgs } from 'node:http';
    import { ParsedUrlQuery, ParsedUrlQueryInput } from 'node:querystring';
    // Input to `url.format`
    interface UrlObject {
        auth?: string | null | undefined;
        hash?: string | null | undefined;
        host?: string | null | undefined;
        hostname?: string | null | undefined;
        href?: string | null | undefined;
        pathname?: string | null | undefined;
        protocol?: string | null | undefined;
        search?: string | null | undefined;
        slashes?: boolean | null | undefined;
        port?: string | number | null | undefined;
        query?: string | null | ParsedUrlQueryInput | undefined;
    }
    // Output of `url.parse`
    interface Url {
        auth: string | null;
        hash: string | null;
        host: string | null;
        hostname: string | null;
        href: string;
        path: string | null;
        pathname: string | null;
        protocol: string | null;
        search: string | null;
        slashes: boolean | null;
        port: string | null;
        query: string | null | ParsedUrlQuery;
    }
    interface UrlWithParsedQuery extends Url {
        query: ParsedUrlQuery;
    }
    interface UrlWithStringQuery extends Url {
        query: string | null;
    }
    /**
     * The `url.parse()` method takes a URL string, parses it, and returns a URL
     * object.
     *
     * A `TypeError` is thrown if `urlString` is not a string.
     *
     * A `URIError` is thrown if the `auth` property is present but cannot be decoded.
     *
     * Use of the legacy `url.parse()` method is discouraged. Users should
     * use the WHATWG `URL` API. Because the `url.parse()` method uses a
     * lenient, non-standard algorithm for parsing URL strings, security
     * issues can be introduced. Specifically, issues with [host name spoofing](https://hackerone.com/reports/678487) and
     * incorrect handling of usernames and passwords have been identified.
     *
     * Deprecation of this API has been shelved for now primarily due to the the
     * inability of the [WHATWG API to parse relative URLs](https://github.com/nodejs/node/issues/12682#issuecomment-1154492373).
     * [Discussions are ongoing](https://github.com/whatwg/url/issues/531) for the  best way to resolve this.
     *
     * @since v0.1.25
     * @param urlString The URL string to parse.
     * @param [parseQueryString=false] If `true`, the `query` property will always be set to an object returned by the {@link querystring} module's `parse()` method. If `false`, the `query` property
     * on the returned URL object will be an unparsed, undecoded string.
     * @param [slashesDenoteHost=false] If `true`, the first token after the literal string `//` and preceding the next `/` will be interpreted as the `host`. For instance, given `//foo/bar`, the
     * result would be `{host: 'foo', pathname: '/bar'}` rather than `{pathname: '//foo/bar'}`.
     */
    function parse(urlString: string): UrlWithStringQuery;
    function parse(urlString: string, parseQueryString: false | undefined, slashesDenoteHost?: boolean): UrlWithStringQuery;
    function parse(urlString: string, parseQueryString: true, slashesDenoteHost?: boolean): UrlWithParsedQuery;
    function parse(urlString: string, parseQueryString: boolean, slashesDenoteHost?: boolean): Url;
    /**
     * The `url.format()` method returns a formatted URL string derived from`urlObject`.
     *
     * ```js
     * const url = require('url');
     * url.format({
     *   protocol: 'https',
     *   hostname: 'example.com',
     *   pathname: '/some/path',
     *   query: {
     *     page: 1,
     *     format: 'json'
     *   }
     * });
     *
     * // => 'https://example.com/some/path?page=1&#x26;format=json'
     * ```
     *
     * If `urlObject` is not an object or a string, `url.format()` will throw a `TypeError`.
     *
     * The formatting process operates as follows:
     *
     * * A new empty string `result` is created.
     * * If `urlObject.protocol` is a string, it is appended as-is to `result`.
     * * Otherwise, if `urlObject.protocol` is not `undefined` and is not a string, an `Error` is thrown.
     * * For all string values of `urlObject.protocol` that _do not end_ with an ASCII
     * colon (`:`) character, the literal string `:` will be appended to `result`.
     * * If either of the following conditions is true, then the literal string `//`will be appended to `result`:
     *    * `urlObject.slashes` property is true;
     *    * `urlObject.protocol` begins with `http`, `https`, `ftp`, `gopher`, or`file`;
     * * If the value of the `urlObject.auth` property is truthy, and either`urlObject.host` or `urlObject.hostname` are not `undefined`, the value of`urlObject.auth` will be coerced into a string
     * and appended to `result`followed by the literal string `@`.
     * * If the `urlObject.host` property is `undefined` then:
     *    * If the `urlObject.hostname` is a string, it is appended to `result`.
     *    * Otherwise, if `urlObject.hostname` is not `undefined` and is not a string,
     *    an `Error` is thrown.
     *    * If the `urlObject.port` property value is truthy, and `urlObject.hostname`is not `undefined`:
     *          * The literal string `:` is appended to `result`, and
     *          * The value of `urlObject.port` is coerced to a string and appended to`result`.
     * * Otherwise, if the `urlObject.host` property value is truthy, the value of`urlObject.host` is coerced to a string and appended to `result`.
     * * If the `urlObject.pathname` property is a string that is not an empty string:
     *    * If the `urlObject.pathname`_does not start_ with an ASCII forward slash
     *    (`/`), then the literal string `'/'` is appended to `result`.
     *    * The value of `urlObject.pathname` is appended to `result`.
     * * Otherwise, if `urlObject.pathname` is not `undefined` and is not a string, an `Error` is thrown.
     * * If the `urlObject.search` property is `undefined` and if the `urlObject.query`property is an `Object`, the literal string `?` is appended to `result`followed by the output of calling the
     * `querystring` module's `stringify()`method passing the value of `urlObject.query`.
     * * Otherwise, if `urlObject.search` is a string:
     *    * If the value of `urlObject.search`_does not start_ with the ASCII question
     *    mark (`?`) character, the literal string `?` is appended to `result`.
     *    * The value of `urlObject.search` is appended to `result`.
     * * Otherwise, if `urlObject.search` is not `undefined` and is not a string, an `Error` is thrown.
     * * If the `urlObject.hash` property is a string:
     *    * If the value of `urlObject.hash`_does not start_ with the ASCII hash (`#`)
     *    character, the literal string `#` is appended to `result`.
     *    * The value of `urlObject.hash` is appended to `result`.
     * * Otherwise, if the `urlObject.hash` property is not `undefined` and is not a
     * string, an `Error` is thrown.
     * * `result` is returned.
     * @since v0.1.25
     * @deprecated Legacy: Use the WHATWG URL API instead.
     * @param urlObject A URL object (as returned by `url.parse()` or constructed otherwise). If a string, it is converted to an object by passing it to `url.parse()`.
     */
    function format(urlObject: URL, options?: URLFormatOptions): string;
    /**
     * The `url.format()` method returns a formatted URL string derived from`urlObject`.
     *
     * ```js
     * const url = require('url');
     * url.format({
     *   protocol: 'https',
     *   hostname: 'example.com',
     *   pathname: '/some/path',
     *   query: {
     *     page: 1,
     *     format: 'json'
     *   }
     * });
     *
     * // => 'https://example.com/some/path?page=1&#x26;format=json'
     * ```
     *
     * If `urlObject` is not an object or a string, `url.format()` will throw a `TypeError`.
     *
     * The formatting process operates as follows:
     *
     * * A new empty string `result` is created.
     * * If `urlObject.protocol` is a string, it is appended as-is to `result`.
     * * Otherwise, if `urlObject.protocol` is not `undefined` and is not a string, an `Error` is thrown.
     * * For all string values of `urlObject.protocol` that _do not end_ with an ASCII
     * colon (`:`) character, the literal string `:` will be appended to `result`.
     * * If either of the following conditions is true, then the literal string `//`will be appended to `result`:
     *    * `urlObject.slashes` property is true;
     *    * `urlObject.protocol` begins with `http`, `https`, `ftp`, `gopher`, or`file`;
     * * If the value of the `urlObject.auth` property is truthy, and either`urlObject.host` or `urlObject.hostname` are not `undefined`, the value of`urlObject.auth` will be coerced into a string
     * and appended to `result`followed by the literal string `@`.
     * * If the `urlObject.host` property is `undefined` then:
     *    * If the `urlObject.hostname` is a string, it is appended to `result`.
     *    * Otherwise, if `urlObject.hostname` is not `undefined` and is not a string,
     *    an `Error` is thrown.
     *    * If the `urlObject.port` property value is truthy, and `urlObject.hostname`is not `undefined`:
     *          * The literal string `:` is appended to `result`, and
     *          * The value of `urlObject.port` is coerced to a string and appended to`result`.
     * * Otherwise, if the `urlObject.host` property value is truthy, the value of`urlObject.host` is coerced to a string and appended to `result`.
     * * If the `urlObject.pathname` property is a string that is not an empty string:
     *    * If the `urlObject.pathname`_does not start_ with an ASCII forward slash
     *    (`/`), then the literal string `'/'` is appended to `result`.
     *    * The value of `urlObject.pathname` is appended to `result`.
     * * Otherwise, if `urlObject.pathname` is not `undefined` and is not a string, an `Error` is thrown.
     * * If the `urlObject.search` property is `undefined` and if the `urlObject.query`property is an `Object`, the literal string `?` is appended to `result`followed by the output of calling the
     * `querystring` module's `stringify()`method passing the value of `urlObject.query`.
     * * Otherwise, if `urlObject.search` is a string:
     *    * If the value of `urlObject.search`_does not start_ with the ASCII question
     *    mark (`?`) character, the literal string `?` is appended to `result`.
     *    * The value of `urlObject.search` is appended to `result`.
     * * Otherwise, if `urlObject.search` is not `undefined` and is not a string, an `Error` is thrown.
     * * If the `urlObject.hash` property is a string:
     *    * If the value of `urlObject.hash`_does not start_ with the ASCII hash (`#`)
     *    character, the literal string `#` is appended to `result`.
     *    * The value of `urlObject.hash` is appended to `result`.
     * * Otherwise, if the `urlObject.hash` property is not `undefined` and is not a
     * string, an `Error` is thrown.
     * * `result` is returned.
     * @since v0.1.25
     * @deprecated Legacy: Use the WHATWG URL API instead.
     * @param urlObject A URL object (as returned by `url.parse()` or constructed otherwise). If a string, it is converted to an object by passing it to `url.parse()`.
     */
    function format(urlObject: UrlObject | string): string;
    /**
     * The `url.resolve()` method resolves a target URL relative to a base URL in a
     * manner similar to that of a web browser resolving an anchor tag.
     *
     * ```js
     * const url = require('url');
     * url.resolve('/one/two/three', 'four');         // '/one/two/four'
     * url.resolve('http://example.com/', '/one');    // 'http://example.com/one'
     * url.resolve('http://example.com/one', '/two'); // 'http://example.com/two'
     * ```
     *
     * To achieve the same result using the WHATWG URL API:
     *
     * ```js
     * function resolve(from, to) {
     *   const resolvedUrl = new URL(to, new URL(from, 'resolve://'));
     *   if (resolvedUrl.protocol === 'resolve:') {
     *     // `from` is a relative URL.
     *     const { pathname, search, hash } = resolvedUrl;
     *     return pathname + search + hash;
     *   }
     *   return resolvedUrl.toString();
     * }
     *
     * resolve('/one/two/three', 'four');         // '/one/two/four'
     * resolve('http://example.com/', '/one');    // 'http://example.com/one'
     * resolve('http://example.com/one', '/two'); // 'http://example.com/two'
     * ```
     * @since v0.1.25
     * @deprecated Legacy: Use the WHATWG URL API instead.
     * @param from The base URL to use if `to` is a relative URL.
     * @param to The target URL to resolve.
     */
    function resolve(from: string, to: string): string;
    /**
     * Returns the [Punycode](https://tools.ietf.org/html/rfc5891#section-4.4) ASCII serialization of the `domain`. If `domain` is an
     * invalid domain, the empty string is returned.
     *
     * It performs the inverse operation to {@link domainToUnicode}.
     *
     * This feature is only available if the `node` executable was compiled with `ICU` enabled. If not, the domain names are passed through unchanged.
     *
     * ```js
     * import url from 'url';
     *
     * console.log(url.domainToASCII('espaÃ±ol.com'));
     * // Prints xn--espaol-zwa.com
     * console.log(url.domainToASCII('ä¸­æ–‡.com'));
     * // Prints xn--fiq228c.com
     * console.log(url.domainToASCII('xn--iÃ±valid.com'));
     * // Prints an empty string
     * ```
     * @since v7.4.0, v6.13.0
     */
    function domainToASCII(domain: string): string;
    /**
     * Returns the Unicode serialization of the `domain`. If `domain` is an invalid
     * domain, the empty string is returned.
     *
     * It performs the inverse operation to {@link domainToASCII}.
     *
     * This feature is only available if the `node` executable was compiled with `ICU` enabled. If not, the domain names are passed through unchanged.
     *
     * ```js
     * import url from 'url';
     *
     * console.log(url.domainToUnicode('xn--espaol-zwa.com'));
     * // Prints espaÃ±ol.com
     * console.log(url.domainToUnicode('xn--fiq228c.com'));
     * // Prints ä¸­æ–‡.com
     * console.log(url.domainToUnicode('xn--iÃ±valid.com'));
     * // Prints an empty string
     * ```
     * @since v7.4.0, v6.13.0
     */
    function domainToUnicode(domain: string): string;
    /**
     * This function ensures the correct decodings of percent-encoded characters as
     * well as ensuring a cross-platform valid absolute path string.
     *
     * ```js
     * import { fileURLToPath } from 'url';
     *
     * const __filename = fileURLToPath(import.meta.url);
     *
     * new URL('file:///C:/path/').pathname;      // Incorrect: /C:/path/
     * fileURLToPath('file:///C:/path/');         // Correct:   C:\path\ (Windows)
     *
     * new URL('file://nas/foo.txt').pathname;    // Incorrect: /foo.txt
     * fileURLToPath('file://nas/foo.txt');       // Correct:   \\nas\foo.txt (Windows)
     *
     * new URL('file:///ä½ å¥½.txt').pathname;      // Incorrect: /%E4%BD%A0%E5%A5%BD.txt
     * fileURLToPath('file:///ä½ å¥½.txt');         // Correct:   /ä½ å¥½.txt (POSIX)
     *
     * new URL('file:///hello world').pathname;   // Incorrect: /hello%20world
     * fileURLToPath('file:///hello world');      // Correct:   /hello world (POSIX)
     * ```
     * @since v10.12.0
     * @param url The file URL string or URL object to convert to a path.
     * @return The fully-resolved platform-specific Node.js file path.
     */
    function fileURLToPath(url: string | URL): string;
    /**
     * This function ensures that `path` is resolved absolutely, and that the URL
     * control characters are correctly encoded when converting into a File URL.
     *
     * ```js
     * import { pathToFileURL } from 'url';
     *
     * new URL('/foo#1', 'file:');           // Incorrect: file:///foo#1
     * pathToFileURL('/foo#1');              // Correct:   file:///foo%231 (POSIX)
     *
     * new URL('/some/path%.c', 'file:');    // Incorrect: file:///some/path%.c
     * pathToFileURL('/some/path%.c');       // Correct:   file:///some/path%25.c (POSIX)
     * ```
     * @since v10.12.0
     * @param path The path to convert to a File URL.
     * @return The file URL object.
     */
    function pathToFileURL(path: string): URL;
    /**
     * This utility function converts a URL object into an ordinary options object as
     * expected by the `http.request()` and `https.request()` APIs.
     *
     * ```js
     * import { urlToHttpOptions } from 'url';
     * const myURL = new URL('https://a:b@æ¸¬è©¦?abc#foo');
     *
     * console.log(urlToHttpOptions(myURL));
     * /*
     * {
     *   protocol: 'https:',
     *   hostname: 'xn--g6w251d',
     *   hash: '#foo',
     *   search: '?abc',
     *   pathname: '/',
     *   path: '/?abc',
     *   href: 'https://a:b@xn--g6w251d/?abc#foo',
     *   auth: 'a:b'
     * }
     *
     * ```
     * @since v15.7.0, v14.18.0
     * @param url The `WHATWG URL` object to convert to an options object.
     * @return Options object
     */
    function urlToHttpOptions(url: URL): ClientRequestArgs;
    interface URLFormatOptions {
        auth?: boolean | undefined;
        fragment?: boolean | undefined;
        search?: boolean | undefined;
        unicode?: boolean | undefined;
    }
    /**
     * Browser-compatible `URL` class, implemented by following the WHATWG URL
     * Standard. [Examples of parsed URLs](https://url.spec.whatwg.org/#example-url-parsing) may be found in the Standard itself.
     * The `URL` class is also available on the global object.
     *
     * In accordance with browser conventions, all properties of `URL` objects
     * are implemented as getters and setters on the class prototype, rather than as
     * data properties on the object itself. Thus, unlike `legacy urlObject` s,
     * using the `delete` keyword on any properties of `URL` objects (e.g. `delete myURL.protocol`, `delete myURL.pathname`, etc) has no effect but will still
     * return `true`.
     * @since v7.0.0, v6.13.0
     */
    class URL {
        /**
         * Creates a `'blob:nodedata:...'` URL string that represents the given `Blob` object and can be used to retrieve the `Blob` later.
         *
         * ```js
         * const {
         *   Blob,
         *   resolveObjectURL,
         * } = require('buffer');
         *
         * const blob = new Blob(['hello']);
         * const id = URL.createObjectURL(blob);
         *
         * // later...
         *
         * const otherBlob = resolveObjectURL(id);
         * console.log(otherBlob.size);
         * ```
         *
         * The data stored by the registered `Blob` will be retained in memory until`URL.revokeObjectURL()` is called to remove it.
         *
         * `Blob` objects are registered within the current thread. If using Worker
         * Threads, `Blob` objects registered within one Worker will not be available
         * to other workers or the main thread.
         * @since v16.7.0
         * @experimental
         */
        static createObjectURL(blob: NodeBlob): string;
        /**
         * Removes the stored `Blob` identified by the given ID. Attempting to revoke a
         * ID that isnâ€™t registered will silently fail.
         * @since v16.7.0
         * @experimental
         * @param id A `'blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`.
         */
        static revokeObjectURL(objectUrl: string): void;
        constructor(input: string, base?: string | URL);
        /**
         * Gets and sets the fragment portion of the URL.
         *
         * ```js
         * const myURL = new URL('https://example.org/foo#bar');
         * console.log(myURL.hash);
         * // Prints #bar
         *
         * myURL.hash = 'baz';
         * console.log(myURL.href);
         * // Prints https://example.org/foo#baz
         * ```
         *
         * Invalid URL characters included in the value assigned to the `hash` property
         * are `percent-encoded`. The selection of which characters to
         * percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.
         */
        hash: string;
        /**
         * Gets and sets the host portion of the URL.
         *
         * ```js
         * const myURL = new URL('https://example.org:81/foo');
         * console.log(myURL.host);
         * // Prints example.org:81
         *
         * myURL.host = 'example.com:82';
         * console.log(myURL.href);
         * // Prints https://example.com:82/foo
         * ```
         *
         * Invalid host values assigned to the `host` property are ignored.
         */
        host: string;
        /**
         * Gets and sets the host name portion of the URL. The key difference between`url.host` and `url.hostname` is that `url.hostname` does _not_ include the
         * port.
         *
         * ```js
         * const myURL = new URL('https://example.org:81/foo');
         * console.log(myURL.hostname);
         * // Prints example.org
         *
         * // Setting the hostname does not change the port
         * myURL.hostname = 'example.com:82';
         * console.log(myURL.href);
         * // Prints https://example.com:81/foo
         *
         * // Use myURL.host to change the hostname and port
         * myURL.host = 'example.org:82';
         * console.log(myURL.href);
         * // Prints https://example.org:82/foo
         * ```
         *
         * Invalid host name values assigned to the `hostname` property are ignored.
         */
        hostname: string;
        /**
         * Gets and sets the serialized URL.
         *
         * ```js
         * const myURL = new URL('https://example.org/foo');
         * console.log(myURL.href);
         * // Prints https://example.org/foo
         *
         * myURL.href = 'https://example.com/bar';
         * console.log(myURL.href);
         * // Prints https://example.com/bar
         * ```
         *
         * Getting the value of the `href` property is equivalent to calling {@link toString}.
         *
         * Setting the value of this property to a new value is equivalent to creating a
         * new `URL` object using `new URL(value)`. Each of the `URL`object's properties will be modified.
         *
         * If the value assigned to the `href` property is not a valid URL, a `TypeError`will be thrown.
         */
        href: string;
        /**
         * Gets the read-only serialization of the URL's origin.
         *
         * ```js
         * const myURL = new URL('https://example.org/foo/bar?baz');
         * console.log(myURL.origin);
         * // Prints https://example.org
         * ```
         *
         * ```js
         * const idnURL = new URL('https://æ¸¬è©¦');
         * console.log(idnURL.origin);
         * // Prints https://xn--g6w251d
         *
         * console.log(idnURL.hostname);
         * // Prints xn--g6w251d
         * ```
         */
        readonly origin: string;
        /**
         * Gets and sets the password portion of the URL.
         *
         * ```js
         * const myURL = new URL('https://abc:xyz@example.com');
         * console.log(myURL.password);
         * // Prints xyz
         *
         * myURL.password = '123';
         * console.log(myURL.href);
         * // Prints https://abc:123@example.com
         * ```
         *
         * Invalid URL characters included in the value assigned to the `password` property
         * are `percent-encoded`. The selection of which characters to
         * percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.
         */
        password: string;
        /**
         * Gets and sets the path portion of the URL.
         *
         * ```js
         * const myURL = new URL('https://example.org/abc/xyz?123');
         * console.log(myURL.pathname);
         * // Prints /abc/xyz
         *
         * myURL.pathname = '/abcdef';
         * console.log(myURL.href);
         * // Prints https://example.org/abcdef?123
         * ```
         *
         * Invalid URL characters included in the value assigned to the `pathname`property are `percent-encoded`. The selection of which characters
         * to percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.
         */
        pathname: string;
        /**
         * Gets and sets the port portion of the URL.
         *
         * The port value may be a number or a string containing a number in the range`0` to `65535` (inclusive). Setting the value to the default port of the`URL` objects given `protocol` will
         * result in the `port` value becoming
         * the empty string (`''`).
         *
         * The port value can be an empty string in which case the port depends on
         * the protocol/scheme:
         *
         * <omitted>
         *
         * Upon assigning a value to the port, the value will first be converted to a
         * string using `.toString()`.
         *
         * If that string is invalid but it begins with a number, the leading number is
         * assigned to `port`.
         * If the number lies outside the range denoted above, it is ignored.
         *
         * ```js
         * const myURL = new URL('https://example.org:8888');
         * console.log(myURL.port);
         * // Prints 8888
         *
         * // Default ports are automatically transformed to the empty string
         * // (HTTPS protocol's default port is 443)
         * myURL.port = '443';
         * console.log(myURL.port);
         * // Prints the empty string
         * console.log(myURL.href);
         * // Prints https://example.org/
         *
         * myURL.port = 1234;
         * console.log(myURL.port);
         * // Prints 1234
         * console.log(myURL.href);
         * // Prints https://example.org:1234/
         *
         * // Completely invalid port strings are ignored
         * myURL.port = 'abcd';
         * console.log(myURL.port);
         * // Prints 1234
         *
         * // Leading numbers are treated as a port number
         * myURL.port = '5678abcd';
         * console.log(myURL.port);
         * // Prints 5678
         *
         * // Non-integers are truncated
         * myURL.port = 1234.5678;
         * console.log(myURL.port);
         * // Prints 1234
         *
         * // Out-of-range numbers which are not represented in scientific notation
         * // will be ignored.
         * myURL.port = 1e10; // 10000000000, will be range-checked as described below
         * console.log(myURL.port);
         * // Prints 1234
         * ```
         *
         * Numbers which contain a decimal point,
         * such as floating-point numbers or numbers in scientific notation,
         * are not an exception to this rule.
         * Leading numbers up to the decimal point will be set as the URL's port,
         * assuming they are valid:
         *
         * ```js
         * myURL.port = 4.567e21;
         * console.log(myURL.port);
         * // Prints 4 (because it is the leading number in the string '4.567e21')
         * ```
         */
        port: string;
        /**
         * Gets and sets the protocol portion of the URL.
         *
         * ```js
         * const myURL = new URL('https://example.org');
         * console.log(myURL.protocol);
         * // Prints https:
         *
         * myURL.protocol = 'ftp';
         * console.log(myURL.href);
         * // Prints ftp://example.org/
         * ```
         *
         * Invalid URL protocol values assigned to the `protocol` property are ignored.
         */
        protocol: string;
        /**
         * Gets and sets the serialized query portion of the URL.
         *
         * ```js
         * const myURL = new URL('https://example.org/abc?123');
         * console.log(myURL.search);
         * // Prints ?123
         *
         * myURL.search = 'abc=xyz';
         * console.log(myURL.href);
         * // Prints https://example.org/abc?abc=xyz
         * ```
         *
         * Any invalid URL characters appearing in the value assigned the `search`property will be `percent-encoded`. The selection of which
         * characters to percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.
         */
        search: string;
        /**
         * Gets the `URLSearchParams` object representing the query parameters of the
         * URL. This property is read-only but the `URLSearchParams` object it provides
         * can be used to mutate the URL instance; to replace the entirety of query
         * parameters of the URL, use the {@link search} setter. See `URLSearchParams` documentation for details.
         *
         * Use care when using `.searchParams` to modify the `URL` because,
         * per the WHATWG specification, the `URLSearchParams` object uses
         * different rules to determine which characters to percent-encode. For
         * instance, the `URL` object will not percent encode the ASCII tilde (`~`)
         * character, while `URLSearchParams` will always encode it:
         *
         * ```js
         * const myUrl = new URL('https://example.org/abc?foo=~bar');
         *
         * console.log(myUrl.search);  // prints ?foo=~bar
         *
         * // Modify the URL via searchParams...
         * myUrl.searchParams.sort();
         *
         * console.log(myUrl.search);  // prints ?foo=%7Ebar
         * ```
         */
        readonly searchParams: URLSearchParams;
        /**
         * Gets and sets the username portion of the URL.
         *
         * ```js
         * const myURL = new URL('https://abc:xyz@example.com');
         * console.log(myURL.username);
         * // Prints abc
         *
         * myURL.username = '123';
         * console.log(myURL.href);
         * // Prints https://123:xyz@example.com/
         * ```
         *
         * Any invalid URL characters appearing in the value assigned the `username`property will be `percent-encoded`. The selection of which
         * characters to percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.
         */
        username: string;
        /**
         * The `toString()` method on the `URL` object returns the serialized URL. The
         * value returned is equivalent to that of {@link href} and {@link toJSON}.
         */
        toString(): string;
        /**
         * The `toJSON()` method on the `URL` object returns the serialized URL. The
         * value returned is equivalent to that of {@link href} and {@link toString}.
         *
         * This method is automatically called when an `URL` object is serialized
         * with [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).
         *
         * ```js
         * const myURLs = [
         *   new URL('https://www.example.com'),
         *   new URL('https://test.example.org'),
         * ];
         * console.log(JSON.stringify(myURLs));
         * // Prints ["https://www.example.com/","https://test.example.org/"]
         * ```
         */
        toJSON(): string;
    }
    /**
     * The `URLSearchParams` API provides read and write access to the query of a`URL`. The `URLSearchParams` class can also be used standalone with one of the
     * four following constructors.
     * The `URLSearchParams` class is also available on the global object.
     *
     * The WHATWG `URLSearchParams` interface and the `querystring` module have
     * similar purpose, but the purpose of the `querystring` module is more
     * general, as it allows the customization of delimiter characters (`&#x26;` and `=`).
     * On the other hand, this API is designed purely for URL query strings.
     *
     * ```js
     * const myURL = new URL('https://example.org/?abc=123');
     * console.log(myURL.searchParams.get('abc'));
     * // Prints 123
     *
     * myURL.searchParams.append('abc', 'xyz');
     * console.log(myURL.href);
     * // ÊDˆE‹ùDˆPûH@AÁËE‹ğDˆX÷AÁÊDˆPòAÁËDˆXöAÁÊAÁËDˆPñDˆXõAÁËAÁÊHƒï…ıÿÿŠD$@H¿^`i«ñD‹µ„  A¼ €L‹l$PH‹µØ  L‹} ¶ÈLFI‰7L‰½  L‰…@  HxÔ ¾   H‰…H  H‰µP  H¾Ó HÇ…`      H‰…X  Hÿµœ D  DF(‹ÖH‹ÈHÿ˜œ D  H‹ğ3ÀH…öuA¿  Àéı  ‹E˜‰Hÿzœ D  L‹E˜º   E‹ÀH‹ÈHÿWœ D  H‹ÈH…ÀuA¿  Àé÷   H‰NL‹E˜I‹×E‹ÀèÉ„ A¿    D‰~Hÿ#œ D  E‹ÇA¿   A‹×H‹ÈHÿ œ D  H‹ÈH…Àt©H‰FHàÒ  AWxHI@ A H0I0@@A@HPIP@`A`HpLğLLD‰~ Hÿ› D  E‹ÇA‹×H‹ÈHÿs› D  H‹È3ÀH…É„ÿÿÿH‰N(D‹øL‹îH‹çÒ H‰3À‹ğH…ö„¼   H‹FH‰EˆH…Àt'Hÿ3› D  L‹Eˆ3ÒH‹ÈHÿ&› D  3ÀH‰FH‹FH‰EˆH…Àt'Hÿÿš D  L‹Eˆ3ÒH‹ÈHÿòš D  3ÀH‰FH‹F(H‰EˆH…Àt'HÿËš D  L‹Eˆ3ÒH‹ÈHÿ¾š D  3ÀH‰F(Hÿ¤š D  L‹Æ3ÒH‹ÈHÿ˜š D  3ÀE…ÿxL‰­à  L‹èëA¿  ÀH‹µ  H…öt)Hÿ_š D  L‹Æ3ÒH‹ÈHÿSš D  3ÀH‰…  M…í„­   I‹uH…öt&Hÿ$š D  L‹Æ3ÒH‹ÈHÿš D  3ÀI‰EI‹uH…öt&Hÿõ™ D  L‹Æ3ÒH‹ÈHÿé™ D  3ÀI‰EI‹u(H…öt&HÿÆ™ D  L‹Æ3ÒH‹ÈHÿº™ D  3ÀI‰E(Hÿ ™ D  M‹Å3ÒH‹ÈHÿ”™ D  AÏ   D‰}°ŒË  L‹­à  A‹M E‹E ƒÁA‹Uƒù‚B  A;Á‚7  ;È‚,  A;Á‚!  B ;È‚  ‰M‹ñHÿ™ D  D‹Æº   H‹ÈHÿÿ˜ D  H‹ğ3ÀH…öuA¿  ÀA½•  Àéİ   A‹E L~‰L;ş‚†   E‹E I‹ÏI‹UèY A‹M IÏI;ÏrjA‹ELy‰L;ùr[E‹EI‹ÏI‹Uè. A‹MIÏI;Ïr?A‹E Ly‰L;ùr0E‹E I‹ÏI‹U(è A‹E IÇI;Çr3ÀH‰t$xD‹ø‹ğ‹E‰EëA¿•  À3ÀH…ö„KÿÿÿHÿ6˜ D  L‹Æ3ÒH‹ÈHÿ*˜ D  A½•  Àë	A½•  ÀE‹ı3ÀAÏ   D‰}°ŒN  ‰EÇE<   ¹H   ‰M‰MH9…˜  uA¿  ÀD‰}°éí   A¹   D9  vâH‹…˜  3É‹ÑHHH;È‚¿   ‹ HÁH;Á‚±   AÑA;ÑrİD‹ HHH;È‚™   3ÀD‰E3ÒE…ÀHEÁH‰…h  ƒ½  v…H‹…˜  HHH;Èrj‹ HÁH;Ár`AÑƒúrå‹HHH;ÈrM3À‰U E3É…ÒHEÁH‰…p  A@PƒøPr/H;Èr(;Ár!‰E$D‰M°E‹ù=  @ vA¿ÿÿ €é<  ‰E ëE‹ıD‰m°E…ÿˆ+  ‹u HÿÌ– D  D‹Æº   H‹ÈHÿ­– D  3ÉH…ÀuL‹l$hA¿  ĞëL‹èH‰D$hA¿   3ÀD‰}°E…ÿˆÖ  H‹D$xH…ÀuA¿W €é»  M…ítğH‰…0  L…x  ‹EHmš ‰…@  ‹E ‰…D  3ÀL‰­8  ‰…H  HHÿu– D  …Àu1Hÿİ• D  ‹U D·øAÏ  €…ÀDNøD‰}°E…ÿxZA¿@ €ëNH‹x  HÍ  Hÿ– D  H…Àt°E3ÉH•0  EA AHfÿ$˜ ‹U D‹øAÏ   M•D  ‰U D‰}°Aÿ#  Ğu¸z €D‹ø‰E°éÕ  3ÀE…ÿˆÌ  H‰EˆƒúsA¿>  Àé  A‹M ME‰L$`M;Å‚ë  Bü;ÁsA¿>  À3Àéİ  NH‰à  L‰U M;Ğ‚½  DIAƒù‚¯  ‹ÂA+ÁƒørÃE‹:MBM;Â‚•  EQE;Ñ‚ˆ  ‹ÂA+ÂA;ÇrœO8M;Ø‚q  G:E;Ê‚d  ‹ÂA+Áƒø‚tÿÿÿE‹+ICH‰E˜I;Ã‚B  EAE;Á‚5  ‹ÂA+ÀA;Å‚EÿÿÿG(E;È‚  A;Ñ…/ÿÿÿAÏ‹ÂAÍHƒÁH;È…ÿÿÿHÿX” D  º   H‹ÈDB(Hÿ8” D  H‹ğ3ÀH…öuA¿  Àéâ  H‹D$hHƒÀt[‹D$`‰Hÿ” D  L‹…à  º   H‹ÈHÿë“ D  H‹ÈH…ÀuA¿  Àéß   H‰NH‹T$hL‹…à  HƒÂèW| ë3À‰H‰FH‹E HƒÀtJD‰~Hÿ£“ D  M‹Çº   H‹ÈHÿ„“ D  L‹ÈH…Àt™H‰FH‹U M‹ÇHƒÂH‹Èèı{ 3Àë	3À‰FH‰FL‹}˜M…ÿtDD‰n HÿG“ D  M‹Åº   H‹ÈHÿ(“ D  H…À„<ÿÿÿH‰F(M‹ÅI‹×H‹Èè¥{ ë‰F H‰F(3ÀH‰uˆ‹ğD‹øH…ö„­   L‹nM…ít&Hÿã’ D  M‹Å3ÒH‹ÈHÿ×’ D  3ÀH‰FL‹nM…ít&Hÿ´’ D  M‹Å3ÒH‹ÈHÿ¨’ D  3ÀH‰FL‹n(M…ít&Hÿ…’ D  M‹Å3ÒH‹ÈHÿy’ D  3ÀH‰F(Hÿ_’ D  L‹Æ3ÒH‹ÈHÿS’ D  3ÀH‹MˆE…ÿH‹ğHHuˆ3ÀE…ÿHHÈH‰L$XH…ö„È   L‹nM…ít&Hÿ’ D  M‹Å3ÒH‹ÈHÿ’ D  3ÀH‰FL‹nM…ít&Hÿß‘ D  M‹Å3ÒH‹ÈHÿÓ‘ D  3ÀH‰FL‹n(M…ít&Hÿ°‘ D  M‹Å3ÒH‹ÈHÿ¤‘ D  3ÀH‰F(HÿŠ‘ D  L‹Æ3ÒH‹ÈHÿ~‘ D  H‹L$X3ÀH‰L$Xë3ÀA¿•  ÀH‹L$XAÏ   D‰}°Œš  H‰…€  H‹ğH‰EˆL‹èH…ÉuA¿  Ğéu  H‹AH‰…à  H…Àtå3À9uA¿  ĞD‰}°éV  D‹9M…ÿ„x  IƒÇøL‰} Hÿä D  M‹Ç3ÒH‹ÈHÿÈ D  L‹ÈH‰E˜3ÀM…É„7  L‹•à  I‹×ˆD$@I‹ÉH‰½Ø  H‰L$Pƒâ„  E3ÀD‰D$pA‹È‰L$HE‹ØA‹ğ…ÒtPDX8‹ØE¶IÿÂƒş}AKàAÓà‹L$HAØëA‹ËAÓà‹L$HAÈ‰L$HÿÆAƒë;ò|É‰\$pH»XJµ±ËÈD‹\$p!D$D‹ñöœ‰šiAó¥e/	A‹ËD‹Æ…ÒtTI‹Ùƒ|$DH{H‰|$P}ÁÁ‹ùëAÁÀA‹øÿD$D@ˆ;H‹|$PH‹ß9T$D|ÍH‹ÏH»XJµ±ËÈH‰L$PH¿^`i«ñëI‹Éƒúv¹   +ÊÁáÓîÓæë3öƒús%N+ÊÁáAÓëAÓãH‹L$Pë3ÒƒL$Hÿ‹ò‰T$pD‹ÚI‹×HÁêH‰U¸H…Ò„B  D‹­Ü  LyH‹]¸A‹ÕD‹t$H3×D‹d$pA·Å‰D$D·…Ú  ‰E°·Ç‰UIR‰D$P‹E¶JÿE‹ÅD¶RşD¶JAÁâDÑAÁá¶
AÁâDÑ¶JAÁâDÑ¶JDÉE3Ú¶JAÁáDÉ¶JHƒÂAÁáH‰U¸DÉA3ñD3Æ‹t$DE3ÃD3ÇA‹ĞA‹È+×ÁÁ
ÁÂ¯ÖÑ·Ú  D3ÚC+ÁÊ	¯ÑA‹ËÁÁ+ÑD3ÂA‹ĞA‹È+ÖÁé¯T$P+Ñ·Ş  D3Ú·•Ú  A3ÓÁÂ¯ÑA‹ËÁÁ+ÑA‹ÍD3Â‹×A3Ğ+ÊD3Ù‹ÎA3ËA‹Ó¯M°ÁÊ3ÑD3ÂA‹ÈÁÁC(ÁÊ¯T$PÑD3ÚA‹Ó·Ş  +×ÁÊ¯ÑA‹ËÁÁ+ÑD3ÂA‹ĞA‹È3×ÁÉ
ÁÊ¯Ö·µŞ  3Ñ·Ú  D3Ú‹ÖA3Ó¯ÑA‹ËÁé
3ÑD3ÂA‹È÷ÑÁÉL$P¯ÎD3Ù·Ş  A‹ó+ñA3ğD‹D$D3÷‹Ö3Ñ‹ÎÁÂA¯ĞÁéÑ·Ú  D3ÚA‹ÓA+ÕÁÊ¯ÑA‹ËÁÁÑA‹È3ò3Î‹Ö¯L$PÁÊ	Ñ·Ú  D3ÚA‹Ó3Ñ·Ş  ÁÂ¯ÑA‹ËÁÁÑ3ò·•Ú  D3ŞD3ØA‹ËÁÉ+ÊA¯È3ñ‹ÖA+ÕÑÊ‹Î¯T$PÁÉ+Ñ·Ş  D3ÚA;ÁÂ¯ÑA‹ËÁÁÑ3ò‹ÎÁÉ>ÁÂA¯Ğ+Ñ·Ú  D3ÚA‹Ó3T$P¯ÑA‹ËÁé3Ñ3òA‹Õ3Ö‹ÎA3öÁÂ¯T$PE‹ñÁÁ3ÑA3ÔE‹âD3ÚH‹U¸Eˆ_üAˆ7MAÁËEˆ_óÁÎAˆw÷AÁËEˆ_òÁÎAˆwöAÁËÁÎEˆ_ñAˆwõÁÎAÁËHƒë…&ıÿÿŠD$@H»XJµ±ËÈD‹µ„  A¼ €L‹mˆL‹} L‹M˜3Ò‹ÊM…ÿtB2	HÿÁI;Ïrô¶ÈH‹…à  I;tH‹µ€  A¿ÕÀ3Àë3ÀL‰€  I‹ñH‰E˜M‹ïD‹ÈD‹øM…Ét*HÿÄ‹ D  L‹E˜3ÒH‹ÈHÿ·‹ D  H‹µ€  3ÀE…ÿx!H‰uÀA¿   H‹ğH‰…€  D‰mëH‹µ€  D‹mA¿  ĞD‰}°H…öt-Hÿa‹ D  L‹Æ3ÒH‹ÈHÿU‹ D  D‹m3ÀH‰…€  E…ÿˆ‡  AƒısA¿>  Àém  L‹MÀE‹IID‰T$PI;É‚N  AEüƒørÓD‹9HqH;ñ‚5  AEøA;ÇrºAGƒø‚  A‹ÍI7E‹ÇI	H;ÂršI‹ÁI+ÇH+ÆHÁHƒøsˆ3À‰D$`D‹èD‹ÈH…ötkH‹ÎH;Ö‚İ   vXHAH;Á‚Î   H;Âw3‹ƒÀƒør4‰E(D‹ĞLÑL;Ñ‚­   I‹ÊL;ÒwAÿÁD‰L$`H;Êsë»A¿  Àé‘   A¿•  ÀëmH;ÊuèE…ÿt6Hÿ,Š D  M‹Çº   H‹ÈHÿŠ D  L‹èH…ÀuA¿  Àë0M‹ÇH…ötH‹ÖI‹Íè‚r ‹D$`‰…   L‰­¨  D‰½¤  3ÀD‹øE…ÿx‹D$P;…   téşÿÿA¿•  ÀAºïD‰}°3ÀH‹u€H…öt"Hÿ™‰ D  L‹Æ3ÒH‹ÈHÿ‰ D  3ÀL‹­à  M…í„¶   I‹uH…öt&Hÿ^‰ D  L‹Æ3ÒH‹ÈHÿR‰ D  3ÀI‰EI‹uH…öt&Hÿ/‰ D  L‹Æ3ÒH‹ÈHÿ#‰ D  3ÀI‰EI‹u(H…öt&Hÿ ‰ D  L‹Æ3ÒH‹ÈHÿôˆ D  3ÀI‰E(HÿÚˆ D  M‹Å3ÒH‹ÈHÿÎˆ D  3ÀH‰…à  H‹t$xH…öt"Hÿ§ˆ D  L‹Æ3ÒH‹ÈHÿ›ˆ D  3ÀH‹t$hH…öt"Hÿ{ˆ D  L‹Æ3ÒH‹ÈHÿoˆ D  3ÀL‹l$XM…í„¯   I‹uH…öt&HÿBˆ D  L‹Æ3ÒH‹ÈHÿ6ˆ D  3ÀI‰EI‹uH…öt&Hÿˆ D  L‹Æ3ÒH‹ÈHÿˆ D  3ÀI‰EI‹u(H…öt&Hÿä‡ D  L‹Æ3ÒH‹ÈHÿØ‡ D  3ÀI‰E(Hÿ¾‡ D  M‹Å3ÒH‹ÈHÿ²‡ D  3ÀH‹uÀH…öt"Hÿ“‡ D  L‹Æ3ÒH‹ÈHÿ‡‡ D  3ÀE…ÿˆ  Aº   D9•   sA¿ÕÀép  H9…¨  uA¿  ÀD‰}°A½•  ÀëV9…   væH‹µ¨  ‹HVH;Ör/E3À‰M,…ÉHEÂH‰…  D‰E°E‹øƒù…İÿÿ‹ ‰…˜  3Àë¯A½•  ÀE‹ıD‰m°E…ÿˆú  D‹½˜  A»z €Aÿ#  ĞEDûD‰}°D‰½˜  E;ût	E…ÿˆÉ  ƒ½   …=ÿÿÿH9…¨  uA¿  ÀD‰}°ëkH‹…¨  3É‹ÑHHH;ÈrN‹ HÁH;ÁrDAÒA;Òrå‹HPH;Ğr13À‰M0E3À…ÉHEÂH‰…˜  D‰E°E‹øƒù…9ÜÿÿH‹ H‰…   ëE‹ıD‰m°3ÀE…ÿˆ3  H9…¨  uA¿  ÀD‰}°ëfH‹…¨  3É‹ÑHHH;ÈrI‹ HÁH;Ár?AÒƒúrå‹HPH;Ğr,3À‰M4E3À…ÉHEÂH‰…¨  D‰E°E‹øƒù…°Ûÿÿ‹ ‰E8ëE‹ıD‰m°3ÀE…ÿˆ¯  H9…¨  uA¿  Àé—  H‹…¨  3É‹ÑHHH;È‚ĞÛÿÿ‹ HÁH;Á‚ÂÛÿÿAÒƒúrİD‹ HHH;È‚ªÛÿÿ3ÀD‰E<E…ÀD‹ÈLEÉL‰°  H‹…¨  3É‹ÑHHH;ÈrM‹ HÁH;ÁrCAÒƒúrå‹HPH;Ğr03À‰M@E3Ò…ÉHEÂH‰…¸  D‰U°E‹úƒù…ØÚÿÿ‹ DQı‰EDëE‹ıD‰m°E…ÿˆÕ   H‹…¨  3É‹ÑHHH;ÈrL‹ HÁH;ÁrBAÒƒúrå‹HPH;Ğr/3À‰MHE3Ò…ÉHEÂH‰…À  D‰U°E‹úƒù…gÚÿÿ‹ ‰…”  ëE‹ıD‰m°E…ÿxiH‹…   H9…¸  …Öüÿÿ‹…”  ‹MD‰…Œ  ‹E8‰…ˆ  ‰  ƒùv	E‹ûD‰]°ë)AƒøwñH‹M¨I‹Ñèl 3ÀE…ÿx‹…˜  …ÀDEøD‰}°3ÀH‹µ˜  ‰…”  ‰…  H…öt)HÿÀƒ D  L‹Æ3ÒH‹ÈHÿ´ƒ D  3ÀH‰…˜  H‹µ¨  ‰…¤  ‰…   H…öt)Hÿƒ D  L‹Æ3ÒH‹ÈHÿsƒ D  3ÀH‰…¨  H‹µĞ  H…öt"HÿJƒ D  L‹Æ3ÒH‹ÈHÿ>ƒ 